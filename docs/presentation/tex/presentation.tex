\documentclass[8pt]{bmstu-pr}

\begin{document}

\prtitle{Метод построения поисковых индексов\\в реляционной базе данных\\на основе
глубоких нейронных сетей}{Маслова Марина Дмитриевна}{ИУ7-83Б}{Оленев Антон
Александрович}

\note{
    Здравствуйте, уважаемые члены комиссии! ...?

    С развитием технологий становится возможным применение новых подходов к
    решению классических задач.

    Так, последнее время стали проводиться исследования по применению методов
    машинного обучения к построению поисковых индексов.

    Поэтому было решено внести небольшой вклад в развитие данного направления
    исследований и разработать...
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Индексы}

    \parbox[t]{\linewidth}{
        Индекс --- это некоторая структура, обеспечивающая быстрый \mbox{поиск}
        записей в базе данных за счет определения соответствия ключа
        \mbox{конкретной} записи положению этой записи.
    }

    \vspace{0.5cm}
    \begin{minipage}{0.50\textwidth}
        \imgfs{multilevel}{h!}{1.1}
    \end{minipage} \hfill
    \begin{minipage}{0.45\textwidth}
        \imgfs{with-no-index}{h!}{0.8}
    \end{minipage}

\end{frame}

\begin{frame}
    \frametitle{Цель и задачи}

    {
    \fontsize{22pt}{22pt}\selectfont
    \parbox[t]{\linewidth}{
        \textbf{Цель:} разработка метода построения поисковых индексов в
        \mbox{реляционной} базе данных на основе глубоких нейронных сетей и его
        программная реализация.
    }

    \vspace{10mm}
    \parbox[t]{\linewidth}{
        \textbf{Задачи:}
        \begin{itemize}
            \item проанализировать методы построения индексов;
            \item разработать метод построения индексов в реляционной базе
                \mbox{данных} на основе глубоких нейронных сетей;
            \item разработать программное обеспечение, реализующее данный
                \mbox{метод};
            \item исследовать операции поиска и вставки с использованием
                \mbox{индекса}, построенного разработанным методом.
        \end{itemize}
    }
    }
\end{frame}

\note{
    метод построения поисковых индексов в реляционной базе данных на основе
    глубоких нейронных сетей, что и стало целью данной работы.

    ~\\
    Для достижения цели необходимо было проанализировать классические методы
    построения индексов, описать построение индексов с использованием нейронных
    сетей, разработать метод и реализующее его программное обеспечение, с
    помощью которого провести исследование.
}  
  
 
\note{
    Как известно индекс представляет собой структуру, строящуюся в дополнение к
    существующим данным и обеспечивающую быстрый поиск записей в базе данных.

    Обычно за основу индекса берут структуру, обеспечивающую выполнение той или
    иной подзадачи поиска:

    \begin{itemize}
        \item b-деревья для поиска в диапазоне;
        \item хеш-таблицы для поиска единичных ключей;
        \item битовые карты, на которых, основан фильтр Блума, --- для проверки
            существования ключа.
    \end{itemize}
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Построение индексов и машинное обучение}

    Классические структуры индексов: B-деревья, хеш-таблицы, битовые карты,
    --- могут быть заменены моделями машинного обучения.

   \imgfh{btolearned-clarify}{h!}{10cm}

\end{frame}

\note{
    Однако каждая из этих структур может быть на более высоком уровне
    представлена в виде модели, сопоставляющей ключ с позицией искомой записи в
    некотором массиве.

    Таким образом, классическая структура может быть заменена моделью машинного
    обучения, предсказывающей позицию по ключу. Индексы с такой моделью называют
    обученными.

    Они предсказывают положение с ошибкой, что требует добавления второго этапа
    для уточнения позиции диапазоне, заданным этой ошибкой.

    %Предсказание становится возможным за счет сортировки массива ключей, позиция
    %в котором может быть предсказана за счет аппроксимацией моделью функции
    %распределения ключей, значение которой может быть преобразовано в позицию по
    %формуле, которую Вы можете видеть на слайде.
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Сравнение методов построения индексов}

{
\fontsize{20pt}{20pt}\selectfont
\renewcommand{\arraystretch}{1.5}
\begin{longtable}[Hc]{|p{4cm}|p{1.5cm}|p{3cm}|p{4cm}|p{2.5cm}|p{4cm}|}
    %>{\columncolor{green}}
    \hline
    \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Критерий сравнения}}} &
    \multicolumn{3}{|c|}{\textbf{Классические индексы}} &
    \multicolumn{1}{c|}{\multirow{2}{*}{\parbox{4cm}{
        \centering\textbf{Обученные индексы}}}}\\
    \cline{3-5}
    \multicolumn{2}{|c|}{} & \multicolumn{1}{c|}{\textbf{B-дерево}} &
    \multicolumn{1}{c|}{\textbf{Хеш-таблица}} &
    \multicolumn{1}{c|}{\parbox{2.5cm}{\centering\textbf{Фильтр Блума}}} & \\
    \hline
    \multirow{2}{*}{\parbox{3cm}{Временная\\сложность}} &
    поиска & O(log N) & O(1) / O(N) & O(k) & O(1) / O(N)\\
    \cline{2-6}
    & вставки & O(log N) & O(1) / O(N) & O(k) & (*)\\
    \hline
    \multicolumn{2}{|l|}{Память} & Высокая & Средняя & Низкая & Средняя\\
    \hline
    \multicolumn{2}{|l|}{Поиск в диапазоне} & + & - & - & + \\
    \hline
    \multicolumn{2}{|l|}{Поиск единичного ключа} & + & + & - & + \\
    \hline
    \multicolumn{2}{|l|}{Проверка существования} & + & + & + & + \\
    \hline
\end{longtable}
}

$(*)$ --- вставка в обученный индекс требует переобучения, сложность которого
зависит от архитектуры используемой модели машинного обучения.
\end{frame}

\note{
    Таким обазом, замена классических структур на модель машинного обучение
    может позволить в лучшем случае осуществлять поиск со сложностью O(1) и 
    в среднем и худшем --- O(N) при необходимости простмотра диапазона

    %, а в случае
    %отсоритрованого массива, дающего также возможность диапазонного поиска, --
    %сложность может быть улучшена до O(log N), что и проводится далее в работе.

    При этом обученные индексы применяются ко всем подзадачам поиска и
    затрачивают постоянное количество памяти на поддержание структуры. Но имеют
    недостаток в виде необходимости переобучения модели при вставке.

    Подробное сравнение с классическими индексами Вы можетет видеть на слайде.
}

\begin{frame}
    \frametitle{Метод построения поисковых индексов}
    \vspace{-1.25cm}
    \imgfh{idef0-build-A1}{h!}{12cm}
\end{frame}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Предварительная обработка данных}

    \begin{minipage}{0.25\textwidth}
        \imgfs{pres-prep}{h!}{1.1}
    \end{minipage} \hfill
    \begin{minipage}{0.70\textwidth}
    \parbox[t]{\linewidth}{
        Нормализация ключей производится в \mbox{диапазон}~$[0, 1]$ по формуле:

        \begin{equation*}
            x_{\text{норм}}= \frac{x - x_{\text{мин}}}{x_{\text{макс}} -
            x_{\text{мин}}},
        \end{equation*}

        ~\\
        где $x_{\text{норм}}$ --- нормализованное значение ключа;

        ~~~~~$x$ --- натуральное значение ключа;

        ~~~~$x_{\text{мин}},~x_{\text{макс}}$ --- минимальное и
        \mbox{максимальное} значение ключа в наборе
        \mbox{соответственно}.
    }
    \end{minipage}
\end{frame}

\begin{frame}
    \fontsize{20pt}{20pt}\selectfont
    \frametitle{Вычисление значений функции распределения}
    \begin{minipage}{0.40\textwidth}
    \parbox[t]{\linewidth}{
    Значение функции \mbox{распределения} \mbox{определяется} по позиции
    ключа по формуле:
    \begin{equation*}
        F(K)  = \frac{p}{N},
    \end{equation*}

    где $F(K)$ --- функция
    \mbox{распределения};

    $K$ --- нормализованный ключ;

    $p$ --- позиция ключа;

    $N$ --- количество ключей.
    }
    \end{minipage}
    \begin{minipage}{0.50\textwidth}
        \imgfs{pres-cdf}{h!}{0.725}
    \end{minipage}
\end{frame}

%\begin{frame}
%    \fontsize{22pt}{22pt}\selectfont
%    \frametitle{Постановка задачи}
%
%    \imgfs{pres-idef0-A0}{h!}{1.4}
%    Ограничение: ключи --- целые уникальные числа.
%
%\end{frame}

\note{
    Для построени обученного индекса из реляционной базы данных получают набор
    ключей и соответсвующих указателей на записи таблицы, подающихся на вход
    разработанного метода. На ключи накладывается ограничение по целочисленности
    и уникальности.

    Результатом работы метода является индекс, представляющий собой структуру,
    состоящей из:
    \begin{itemize}
        \item обученной модели глубокой нейронной сети;
        \item массивов ключей и указателей;
        \item абсолютной ошибки, задающей диапазон поиска.
    \end{itemize}
}

\begin{frame}
    \fontsize{20pt}{20pt}\selectfont
    \frametitle{Архитектура нейронной сети}
    \begin{minipage}{0.50\textwidth}
        \imgfs{fcnn2}{h!}{1}
        \vspace{-1cm}
        \imgfs{fcnn3}{h!}{1}
    \end{minipage}
    \begin{minipage}{0.45\textwidth}
        1 вход: нормализованный ключ $K$.

        1 выход: значение функции\\распределения $F(K)$.

        2-3 скрытых слоя по 32 нейрона.

        Функция активации: ReLU.

        ~\\
    \end{minipage}
\end{frame}

\note{
    Для работы метода также должны быть заданы правила предварительной
    обработки, определяющиеся архитектурой глубокой нейронной сети, принимаемой
    в качестве модели обученного индекса.
    
    На основе предыдущих исследований для моделей нейронной сети были выбраны
    параметры, которые представлены на слайде.

    Ключевым моментом для обучения нейронной сети является нормализация входный и
    выходных значений, на которых обучается и работает модель.
}

\note{
    Значение ключа отображается в дапазон [0, 1] с помощью минимакс
    нормализации. Выходные значения для обучения нормализуются путем вычисления
    эмпирической функции распределения ключей по их позициям в отсортированном
    массиве по формуле на слайде.
}


\note{
    Сортировка набора ключей дает также возможность диапазонного поиска.
    
    Поэтому на этапе метода предварительной обработки происходит согласованная
    сортировка массивов ключей и указателей c нормализацией ключей. На втором
    этапе вычисляются значения функции распределения.

    Результаты первого и второго этапа передаются на вход этапа обучения модели
    глубокой нейронной сети, выдающий на выходе необходимый индекс.
}

\begin{frame}
    \frametitle{Применение метода: поиск}
    \vspace{-1.25cm}
    \imgfh{pres-idef0-search-A1}{h!}{11.5cm}
\end{frame}

\note{
    Для оценки работы метода тажке разработаты алгоритмы поиска и вставки в
    построенном индексе.

    Поиск включает в себя тот же этап нормализации ключа или границ диапазона
    ключей, этап получения предсказанной нейронной сетью позиции, этап ее
    уточнения, который осуществляется бинарным поиском с учетом
    отсортированности массива, и этап получения соответсвующего учточненной
    позиции ключа указателя на данные.
}

\begin{frame}
    \frametitle{Применение метода: вставка}
    \vspace{-0.5cm}
    \imgfh{insert-A1}{h!}{12cm}
\end{frame}

\note{
    Вставка представляет собой комбинацию алгоритов поиска и построения, то есть
    включает этап получения позиции для вставки только что описанным алгоритмом
    без получения указателя на данные, этап изменения массивов и этап обучения
    модели на новых данных, начиная с уже рассчитанных весов модели.
}

\begin{frame}
    \frametitle{Структура программного обеспечения}
    %#\vspace{-1.25cm}
    \imgfh{pres-sw-struct}{h!}{10cm}
\end{frame}

\note{
    Для реализации метода поистроения индекса было разработано программное
    обеспечения, включающее модуль взаимодействия с реляционной базой данных, в
    качестве которой была выбрана SQLite, модуль реализции индекса на основе
    глубоких нейронных сетей и готовый модуль взаимодействия с пользователем,
    представленный интерфейсом SQLite.
}

\begin{frame}
    \frametitle{Зависимость времени построения и размера индекса от количества
    ключей}

    \imgfh{pres-build-mem}{h!}{11cm}
\end{frame}

\note{
    С использованием разработанного ПО было проведено исследование
    разработанного индекса в сравнении с реализцией B-дерева в SQLite, на
    моделях с 2 и 3 слоями, на трех различных распределениях ключей.

    По результатам исследования выявлена:
    \begin{itemize}
        \item линейная зависимость времени построения от количества ключей у
            обоих типов индексов, c увеличением времени построения на 10\% при
            добавлении дополнительного слоя модели;
        \item линейный рост размеров обоих индексов при увеличении числа
            ключей.
    \end{itemize}
}

\begin{frame}
    \frametitle{Зависимость времени поиска и средней абсолютной ошибки от
    количества ключей}

    \imgfh{pres-search-comp}{h!}{11cm}
\end{frame}

\note{
    Также выявлено стремление отношения средней абсолютной ошибки модели для
    каждого распределения к некоторой постоянной, что обеспечивает
    логарифмическую сложность поиска.

    Выявлена меньшее значение ошибки на классических распределениях и как
    следствие меньшее время поиска.

    На представленных графиках отображено, что добавление третьего слоя к модели
    нейронной сети необравдано, так как сокращение времени бинарного поиска в
    меньшем диапазоне за счет большей точность перекрылось затратами на
    вычисления дополнительных коэффициентов
}

\begin{frame}
    \frametitle{Зависимость времени этапов поиска от количества ключей и
    распределение средней абсолютной ошибки}
    \imgfh{pres-search-steps}{h!}{11cm}
\end{frame}

\note{
    Исследование поиска по этапам дало постоянное время предскания позиции,
    логарифмическую зависимость времени бинарного поиска от числа ключей, и как
    следствие логарифмическую сложность поиска с помощью разработанного индекса.

    При этом линейный рост размера диапазона осуществления бинарного поиска
    происходит с коэффициентов, лежащим пределах от 0 до 0.6\%, что представлено
    на гистограмме.
}

\begin{frame}
    \frametitle{Зависимость времени поиска и вставки от количества ключей в
    сравнении с классическим индексом}
    \vspace{-0.2cm}
    \imgfh{pres-search-insert}{h!}{11.5cm}
\end{frame}

\note{
    Исследование времени поиска и вставки разработанного индекса в сранении с
    индексом SQLite показало одинаковые порядки значений времени поиска при
    логарифмических зависимостях у обоих индексов, и превышение в десятки раз
    времени вставки в разработанный индекс времени индекса SQLite, при линейном
    и логарифмическом росте соответсвенно.
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Заключение}

    \parbox[t]{\linewidth}{
        Разработан и реализован метод построения поисковых индексов в
        реляционной базе данных на основе глубоких нейронных сетей для чего:
    }

    ~\\
    \parbox[t]{\linewidth}{
        \begin{itemize}
            \item проанализированы методы построения индексов;
            \item разработан метод построения индексов в реляционной базе
                \mbox{данных} на основе глубоких нейронных сетей;
            \item разработано программное обеспечение, реализующее данный
                \mbox{метод};
            \item проведено исследование операций поиска и вставки с
                \mbox{использованием} индекса, построенного разработанным
                методом.
        \end{itemize}
    }
    ~\\
\end{frame}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Дальнейшее развитие}
    \begin{enumerate}
        \item Оптимизация алгоритма вставки с учетом распределения ключей.
        \item Добавление возможности построения индекса по ключам других типов
            данных.
        \item  Построение многомерных обученных индексов.
    \end{enumerate}
    ~\\
\end{frame}

\end{document}

