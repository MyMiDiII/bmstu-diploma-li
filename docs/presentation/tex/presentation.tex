\documentclass[8pt]{bmstu-pr}

\begin{document}

\prtitle{Метод построения поисковых индексов\\в реляционной базе данных\\на основе
глубоких нейронных сетей}{Маслова Марина Дмитриевна}{ИУ7-83Б}{Оленев Антон
Александрович}

\note{
    Здравствуйте, уважаемые члены комиссии! ...?

    С развитием технологий становится возможным применение новых подходов к
    решению классических задач.

    Так, последнее время стали проводиться исследования по применению методов
    машинного обучения к построению поисковых индексов.

    Поэтому было решено внести небольшой вклад в развитие данного направления
    исследований и разработать...
}

\begin{frame}
    \frametitle{Цель и задачи}

    {
    \fontsize{22pt}{22pt}\selectfont
    \textbf{Цель:} разработка метода построения поисковых индексов в реляционной
    базе данных на основе глубоких нейронных сетей.

    \vspace{2mm}
    \textbf{Задачи:}
    \begin{itemize}
        \item рассмотреть и сравнить известные методы построения индексов;
        \item привести описание построения индексов с помощью нейронных сетей;
        \item разработать метод построения индексов в реляционной базе
            данных на основе глубоких нейронных сетей;
        \item разработать программное обеспечение, реализующее данный метод;
        \item провести исследование (по времени и памяти) операций поиска и вставки
            с использованием индекса, построенного разработанным методом, при
            различных объемах данных.
    \end{itemize}
    }
\end{frame}

\note{
    метод построения поисковых индексов в реляционной базе данных на основе
    глубоких нейронных сетей, что и стало целью данной работы.

    ~\\
    Для достижения цели необходимо было проанализировать классические методы
    построения индексов, описать построение индексов с использованием нейронных
    сетей, разработать метод и реализующее его программное обеспечение, с
    помощью которого провести исследование.
}  
  
\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Классические структуры индексов}

    Индекс --- это некоторая структура, обеспечивающая быстрый поиск записей в
    базе данных за счет определяет соответствие ключа поиска конкретной записи с
    положением этой записи.

    \vspace{0.5cm}
    \begin{minipage}{0.55\textwidth}
        \imgfs{multilevel}{h!}{1.1}
    \end{minipage} \hfill
    \begin{minipage}{0.40\textwidth}
        Основные типы структур:
        \begin{itemize}
            \item B-деревья;
            \item хеш-таблицы;
            \item битовые карты.
        \end{itemize}
    \end{minipage}

\end{frame}
 
\note{
    Как известно индекс представляет собой структуру, строящуюся в дополнение к
    существующим данным и обеспечивающую быстрый поиск записей в базе данных.

    Обычно за основу индекса берут структуру, обеспечивающую выполнение той или
    иной подзадачи поиска:

    \begin{itemize}
        \item b-деревья для поиска в диапазоне;
        \item хеш-таблицы для поиска единичных ключей;
        \item битовые карты, на которых, основан фильтр Блума, --- для проверки
            существования ключа.
    \end{itemize}
}

\begin{frame}
    \fontsize{20pt}{20pt}\selectfont
    \frametitle{Обученные индексы}

    \imgfh{btolearned-clarify}{h!}{12cm}
\end{frame}

\note{
    Однако каждая из этих структур может быть на более высоком уровне
    представлена в виде модели, сопоставляющей ключ с позицией искомой записи в
    некотором массиве.

    Таким образом, классическая структура может быть заменена моделью машинного
    обучения, предсказывающей позицию по ключу. Индексы с такой моделью называют
    обученными.

    Они предсказывают положение с ошибкой, что требует добавления второго этапа
    для уточнения позиции диапазоне, заданным этой ошибкой.

    %Предсказание становится возможным за счет сортировки массива ключей, позиция
    %в котором может быть предсказана за счет аппроксимацией моделью функции
    %распределения ключей, значение которой может быть преобразовано в позицию по
    %формуле, которую Вы можете видеть на слайде.
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Сравнение методов построения индексов}

{
\fontsize{20pt}{20pt}\selectfont
\renewcommand{\arraystretch}{1.5}
\begin{longtable}[Hc]{|p{4cm}|p{1.5cm}|p{3cm}|p{4cm}|p{2.5cm}|p{4cm}|}
    %>{\columncolor{green}}
    \hline
    \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Метод}}} &
    \multicolumn{3}{|c|}{\textbf{Классические индексы}} &
    \multicolumn{1}{c|}{\multirow{2}{*}{\parbox{4cm}{
        \centering\textbf{Обученные индексы}}}}\\
    \cline{3-5}
    \multicolumn{2}{|c|}{} & \multicolumn{1}{c|}{\textbf{B-дерево}} &
    \multicolumn{1}{c|}{\textbf{Хеш-таблица}} &
    \multicolumn{1}{c|}{\parbox{2.5cm}{\centering\textbf{Фильтр Блума}}} & \\
    \hline
    \multirow{2}{*}{\parbox{3cm}{Временная\\сложность}} &
    поиска & O(log N) & O(1) / O(N) & O(k) & O(1) / O(N)\\
    \cline{2-6}
    & вставки & O(log N) & O(1) / O(N) & O(k) & (*)\\
    \hline
    \multicolumn{2}{|l|}{Память} & Высокая & Средняя & Низкая & Средняя\\
    \hline
    \multicolumn{2}{|l|}{Поиск в диапазоне} & + & - & - & + \\
    \hline
    \multicolumn{2}{|l|}{Поиск единичного ключа} & + & + & - & + \\
    \hline
    \multicolumn{2}{|l|}{Проверка существования} & + & + & + & + \\
    \hline
\end{longtable}
}

$(*)$ --- вставка в обученный индекс требует переобучения, сложность которого
зависит от архитектуры используемой модели машинного обучения.
\end{frame}

\note{
    Таким обазом, замена классических структур на модель машинного обучение
    может позволить в лучшем случае осуществлять поиск со сложностью O(1) и 
    в среднем и худшем --- O(N) при необходимости простмотра диапазона

    %, а в случае
    %отсоритрованого массива, дающего также возможность диапазонного поиска, --
    %сложность может быть улучшена до O(log N), что и проводится далее в работе.

    При этом обученные индексы применяются ко всем подзадачам поиска и
    затрачивают постоянное количество памяти на поддержание структуры. Но имеют
    недостаток в виде необходимости переобучения модели при вставке.

    Подробное сравнение с классическими индексами Вы можетет видеть на слайде.
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Постановка задачи}

    \imgfs{pres-idef0-A0}{h!}{1.4}
    Ограничение: ключи --- целые уникальные числа.

\end{frame}

\note{
    Для построени обученного индекса из реляционной базы данных получают набор
    ключей и соответсвующих указателей на записи таблицы, подающихся на вход
    разработанного метода. На ключи накладывается ограничение по целочисленности
    и уникальности.

    Результатом работы метода является индекс, представляющий собой структуру,
    состоящей из:
    \begin{itemize}
        \item обученной модели глубокой нейронной сети;
        \item массивов ключей и указателей;
        \item абсолютной ошибки, задающей диапазон поиска.
    \end{itemize}
}

\begin{frame}
    \fontsize{20pt}{20pt}\selectfont
    \frametitle{Архитектура нейронной сети}
    \begin{minipage}{0.50\textwidth}
        \imgfs{fcnn2}{h!}{1}
        \vspace{-1cm}
        \imgfs{fcnn3}{h!}{1}
    \end{minipage}
    \begin{minipage}{0.45\textwidth}
        1 вход: нормализованный ключ $K$.

        1 выход: значение функции\\распределения $F(K)$.

        2-3 скрытых слоя по 32 нейрона.

        Функция активации: ReLU.

        ~\\
        Определение \mbox{значения} функции \mbox{распределения} по позиции
        ключа:
        \begin{equation*}
            F(K)  = \frac{p}{N},
        \end{equation*}

        где $p$ --- искомая позиция;

        ~~~~$K$ --- ключ поиска;

        ~~~~$F(K)$ --- функция

        ~~~~распределения;

        ~~~~$N$ --- количество ключей.
    \end{minipage}
\end{frame}

\note{
    Для работы метода также должны быть заданы правила предварительной
    обработки, определяющиеся архитектурой глубокой нейронной сети, принимаемой
    в качестве модели обученного индекса.
    
    На основе предыдущих исследований для моделей нейронной сети были выбраны
    параметры, которые представлены на слайде.

    Ключевым моментом для обучения нейронной сети является нормализация входный и
    выходных значений, на которых обучается и работает модель.
}

\note{
    Значение ключа отображается в дапазон [0, 1] с помощью минимакс
    нормализации. Выходные значения для обучения нормализуются путем вычисления
    эмпирической функции распределения ключей по их позициям в отсортированном
    массиве по формуле на слайде.
}

\begin{frame}
    \frametitle{Функциональная схема построения индекса}
    \vspace{-1.25cm}
    \imgfh{pres-idef0-A1}{h!}{12cm}
\end{frame}

\note{
    Сортировка набора ключей дает также возможность диапазонного поиска.
    
    Поэтому на этапе метода предварительной обработки происходит согласованная
    сортировка массивов ключей и указателей c нормализацией ключей. На втором
    этапе вычисляются значения функции распределения.

    Результаты первого и второго этапа передаются на вход этапа обучения модели
    глубокой нейронной сети, выдающий на выходе необходимый индекс.
}

\begin{frame}
    \frametitle{Функциональная схема поиска}
    \vspace{-1.25cm}
    \imgfh{pres-idef0-search-A1}{h!}{11.5cm}
\end{frame}

\note{
    Для оценки работы метода тажке разработаты алгоритмы поиска и вставки в
    построенном индексе.

    Поиск включает в себя тот же этап нормализации ключа или границ диапазона
    ключей, этап получения предсказанной нейронной сетью позиции, этап ее
    уточнения, который осуществляется бинарным поиском с учетом
    отсортированности массива, и этап получения соответсвующего учточненной
    позиции ключа указателя на данные.
}

\begin{frame}
    \frametitle{Функциональная схема вставки}
    \vspace{-0.5cm}
    \imgfh{insert-A1}{h!}{12cm}
\end{frame}

\note{
    Вставка представляет собой комбинацию алгоритов поиска и построения, то есть
    включает этап получения позиции для вставки только что описанным алгоритмом
    без получения указателя на данные, этап изменения массивов и этап обучения
    модели на новых данных, начиная с уже рассчитанных весов модели.
}

\begin{frame}
    \frametitle{Структура программного обеспечения}
    %#\vspace{-1.25cm}
    \imgfh{pres-sw-struct}{h!}{10cm}
\end{frame}

\note{
    Для реализации метода поистроения индекса было разработано программное
    обеспечения, включающее модуль взаимодействия с реляционной базой данных, в
    качестве которой была выбрана SQLite, модуль реализции индекса на основе
    глубоких нейронных сетей и готовый модуль взаимодействия с пользователем,
    представленный интерфейсом SQLite.
}

\begin{frame}
    \frametitle{Исследование времени построения и размера индекса}

    \vspace{-1cm}
    \imgfh{pres-build-mem}{h!}{12cm}
\end{frame}

\note{
    С использованием разработанного ПО было проведено исследование
    разработанного индекса в сравнении с реализцией B-дерева в SQLite, на
    моделях с 2 и 3 слоями, на трех различных распределениях ключей.

    По результатам исследования выявлена:
    \begin{itemize}
        \item линейная зависимость времени построения от количества ключей у
            обоих типов индексов, c увеличением времени построения на 10\% при
            добавлении дополнительного слоя модели;
        \item линейный рост размеров обоих индексов при увеличении числа
            ключей.
    \end{itemize}
}

\begin{frame}
    \frametitle{Исследование времени поиска}

    \vspace{-1.25cm}
    \imgfh{pres-search-comp}{h!}{12cm}
\end{frame}

\note{
    Также выявлено стремление отношения средней абсолютной ошибки модели для
    каждого распределения к некоторой постоянной, что обеспечивает
    логарифмическую сложность поиска.

    Выявлена меньшее значение ошибки на классических распределениях и как
    следствие меньшее время поиска.

    На представленных графиках отображено, что добавление третьего слоя к модели
    нейронной сети необравдано, так как сокращение времени бинарного поиска в
    меньшем диапазоне за счет большей точность перекрылось затратами на
    вычисления дополнительных коэффициентов
}

\begin{frame}
    \frametitle{Исследование времени поиска}
    \vspace{-1.25cm}
    \imgfh{pres-search-steps}{h!}{12cm}
\end{frame}

\note{
    Исследование поиска по этапам дало постоянное время предскания позиции,
    логарифмическую зависимость времени бинарного поиска от числа ключей, и как
    следствие логарифмическую сложность поиска с помощью разработанного индекса.

    При этом линейный рост размера диапазона осуществления бинарного поиска
    происходит с коэффициентов, лежащим пределах от 0 до 0.6\%, что представлено
    на гистограмме.
}

\begin{frame}
    \frametitle{Исследование времени поиска и вставки}
    \vspace{-1.25cm}
    \imgfh{pres-search-insert}{h!}{12cm}
\end{frame}

\note{
    Исследование времени поиска и вставки разработанного индекса в сранении с
    индексом SQLite показало одинаковые порядки значений времени поиска при
    логарифмических зависимостях у обоих индексов, и превышение в десятки раз
    времени вставки в разработанный индекс времени индекса SQLite, при линейном
    и логарифмическом росте соответсвенно.
}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Заключение}
    В ходе данной работы:
    \begin{itemize}
        \item проанализированы известные методы построения индексов;
        \item приведено описание построения индексов с помощью нейронных сетей;
        \item разработан метод построения индексов в реляционной базе
            данных на основе глубоких нейронных сетей;
        \item разработано программное обеспечение, реализующее данный метод;
        \item проведено исследование (по времени и памяти) операций поиска и
            вставки с использованием индекса, построенного разработанным
            методом, при различных объемах данных.
    \end{itemize}
    ~\\

    Поставленная цель достигнута.
\end{frame}

\begin{frame}
    \fontsize{22pt}{22pt}\selectfont
    \frametitle{Дальнейшее развитие}
    \begin{enumerate}
        \item Оптимизация алгоритма вставки с учетом распределения ключей.
        \item Добавление возможности построения индекса по ключам других типов
            данных.
        \item  Построение многомерных обученных индексов.
    \end{enumerate}
    ~\\
\end{frame}

\end{document}

