\chapter{Описание существующих методов построения индексов\label{methods}}

Как было сказано выше индексы обеспечивают быстрый поиск записей, поэтому в их
основе лежат структуры, предназначенные для решения этой задачи. По данным
структурам индексы подразделяются на
\begin{itemize}
    \item индексы на основе деревьев поиска,
    \item индексы на основе хеш-таблиц,
    \item индексы на основе битовых карт.
\end{itemize}

При этом каждой из представленных групп индексов соответствует своя подзадача,
которую решают данные индексы, что подробнее описано далее.

\section{Индексы на основе деревьев поиска}

Дерево поиска --- иерархическая структура, используемая для поиска
записей, которая осуществляет работу с отсортированными значениями ключей и в
которой каждый переход на более низкий уровень иерархии уменьшает интервал
поиска. При использовании деревьев поиска для построения индексов необходимо
учитывать, что требуется обеспечить как ускорение поиска данных, так и
уменьшение затрат на обновление индекса при вставках и удалениях. По этим
причинам при решении задачи поиска в базах данных используют сбалансированные
сильноветвящиеся деревья~\cite{arki}.

В данном случае сбалансированными деревьями называют такие деревья, что
длины любых двух путей от корня до листьев одинаковы~\cite{encycl}.
Сильноветвящимися же являются деревья, каждый узел которых ссылается на
большое число потомков~\cite{squares}.  Эти условия обеспечивают минимальную
высоту дерева для быстрого поиска и свободное пространство в узлах для внесения
изменений в базу данных без необходимости изменения индекса при каждой операции.

Наиболее используемыми деревьями поиска, имеющими описанные свойства, являются
B-деревья и их разновидность --- B$^+$-деревья~\cite{arki}.

\subsection{B-деревья}

B-дерево --- это сбалансированная, сильноветвящаяся древовидная,
работающая с отсортированными значениями структура данных, операции вставки и
удаления в которой не изменяют ее свойств~\cite{loshad}. Все свойства данной
структуры поддерживаются путем сохранения в узлах положений для включения новых
элементов~\cite{baw}. Это осуществляется за счет свойств узлов, которые
определяются порядком B-дерева~$m$.

B-деревом порядка~$m$~\cite{baw, arki} называется дерево поиска, такое
что:

\begin{itemize}
    \item каждый узел имеет формат, описывающийся формулой~\eqref{eq:01}:
        \begin{equation}\label{eq:01}
            (P_1, (K_1, Pr_1), P_2, (K_2, Pr_2), \dots, (K_{q-1}, Pr_{q-1}),
            P_q),
        \end{equation}

        где $q \leqslant m$,

        $P_i$ --- указатель на $i$-ого потомка в случае внутреннего узла или
        пустой указатель в случае внешнего~(листа),

        $K_i$ --- ключи поиска,

        $Pr_i$ --- указатель на запись, соответствующую ключу поиска $K_i$;

    \item для каждого узла выполняется $K_1 < K_2 < \dots < K_q$;

    \item для каждого ключа поиска $X$ потомка, лежащего по указателю $P_i$
        выполняются условия, описывающиеся формулой~\eqref{eq:02}:

        \begin{equation}\label{eq:02}
            \begin{aligned}
                K_{i-1} < X < K_i, & \text{ если } 1 < i < q,\\
                X < K_i, & \text{ если } i = 1,\\
                K_{i-1} < X, & \text{ если } i = q;
            \end{aligned}
        \end{equation}

    \item каждый узел содержит не более $m - 1$~ключей поиска или, что то же
        самое, имеет не более $m$~потомков;

    \item каждый узел за исключением корня содержит не менее $\lceil m / 2
        \rceil - 1$~ключей поиска, или, что то же самое, имеет не менее~$\lceil
        m / 2 \rceil$ потомков;

    \item корень может содержать минимум один ключ, либо, что то же самое, иметь
        минимум два потомка;

    \item каждый узел за исключением листьев, содержащий $q-1$~ключей, имеет
        $q$~потомков;

    \item все листья находятся на одном и том же уровне.
\end{itemize}

В случае с индексами к каждому ключу поиска во всех узлах добавляется указатель
на запись, соответствующую этому ключу. Другими словами, каждый узел содержит
набор указателей, ссылающихся на дочерние узлы, и набор пар, каждая из которых
состоит из ключа поиска и указателя, ссылающегося на данные. При этом записи с
данными хранятся отдельно и частью B-дерева не являются~\cite{arki}.

Пример B-дерева представлен на рисунке~\ref{img:node}.
~\\

\imgs{node}{h!}{1}{Пример B-дерева}

Построение B-дерева~\cite{flatfish} начинается с создания корневого узла. В него
происходит вставка до полного заполнения, то есть до того момента, пока все
$q-1$ позиций не будут заняты. При вставке $q$-ого значения создается новый
корень, в который переносится только медиана значений, старый корень разделяется
на два узла, между которыми равномерно распределяются оставшиеся
значения~(рисунок~\ref{img:rootInsert}). Два созданных узла становятся потомками
нового корня.

\imgw{rootInsert}{h!}{17cm}{Пример вставки в B-дерево при заполненном корне}

Когда некорневой узел заполнен и в него должен быть вставлен новый ключ, этот
узел разделяется на два узла на том же уровне, а средняя запись перемещается в
родительский узел вместе с двумя указателями на новые разделенные узлы. Если
родительский узел заполнен, он также разделяется. Разделение может
распространяться вплоть до корневого узла, при разделении которого создается
новый уровень~(рисунок~\ref{img:leafInsert}). Фактически дерево строится
последовательным выполнением операций вставки.

\imgw{leafInsert}{h!}{17cm}{Пример вставки в B-дерево при последовательном
заполнении узлов разных уровней}

Удаление значений основано на той же идее. Нужное значение удаляется из узла, в
котором оно находится, и если количество значений в узле становится меньше
половины максимально возможного количества значений, то узел объединяется с
соседними узлами, что также может распространяться вплоть до корня~\cite{marvel}. 

Поиск в B-дереве начинается с корня. Если искомое ключевое значение $X$ найдено
в узле, то есть какой либо ключ $K_i$ в нем равен $X$, то доступ к нужной записи
осуществляется по соответствующему указателю $Pr_i$. Если значение не найдено,
происходит переход к поддереву по указателю $P_i$, соответствующему наименьшему
значению $i$, такому, что $X < K_i$. Если $X$ больше $K_i$ для любого значения
$i \in \overline{1, q - 1}$, то переход осуществляется по указателю $P_q$.
Далее действия повторяются для того поддерева, к которому произошел переход, до
тех пор, пока не будет найдено нужное значение или не будет достигнут конец
листового узла, что означает отсутствие искомого ключа~\cite{arki}.

Таким образом, можно выделить следующие основные свойства
\mbox{B-деревьев}~\cite{marvel}:
\begin{itemize}
    \item ключи и указатели на данные хранятся во всех узлах дерева;
    \item как следствие первого свойства, поиск различных ключей может
        выполняться проходом по разному числу узлов, но максимальная длина пути
        равна высоте дереве, что дает временную сложность поиска в среднем
        случае --- $O(\log N)$;
    \item операции вставки и удаления также имеют временную сложность в среднем
        случае --- $O(\log N)$;
    \item в случае поиска по ключам, принадлежащим некоторому диапазону,
        требуется переход от дочерних узлов к родительским и наоборот, что
        является главным недостатком B-дерева.
\end{itemize}

\subsection{B$^+$-деревья}

Для устранения недостатков B-деревьев были введены B$^+$-деревья~\cite{marvel},
структура которых аналогична структуре B-дерева за исключением двух
моментов~\cite{arki}.  Во-первых, внутренние узлы не содержат указателей на
записи, в них хранятся только значения ключей, то есть внутренние узлы имеют
формат, описывающийся формулой~\eqref{eq:03}:

\begin{equation}\label{eq:03}
    (P_1, K_1, P_2, K_2, \dots, K_{q-1}, P_q),
\end{equation}

где $q \leqslant m$,

$P_i$ --- указатель на $i$-ого потомка,

$K_i$ --- ключи поиска.

Указатели на данные содержатся только в листьях. При этом каждый ключ,
содержащийся во внутренних узлах, встречается в каком-либо листе, то есть
условие, представленное формулой~\eqref{eq:02}, для B$^+$-деревьев
модернизируется в формулу~\eqref{eq:04}:

\begin{equation}\label{eq:04}
    \begin{aligned}
        K_{i-1} < X \leqslant K_i, & \text{ если } 1 < i < q,\\
        X \leqslant K_i, & \text{ если } i = 1,\\
        K_{i-1} < X, & \text{ если } i = q.
    \end{aligned}
\end{equation}

Все остальные свойства B-дерева порядка $m$ верны и для B$^+$-дерева.

Во-вторых, каждый листовой узел содержит только пары (ключ, указатель на данные)
и не содержит указателей на потомков, так как при любых операциях лист не может
стать внутренним узлом, а также структура внешнего узла отличается от структуры
внутренних. При этом в конец каждого листа добавляется указатель на следующий
лист.

Пример B$^+$-дерева приведен на рисунке~\ref{img:bplustree}.

\imgs{bplustree}{h!}{0.95}{Пример B$^+$-дерева}

В силу того, что листы имеют структуру, они могут иметь порядок отличный от
порядка внутренних узлов, что позволяет уменьшить высоту дерева, а следовательно
и количество блоков памяти, к которым необходимо обратиться, что позволяет
сократить время поиска. Наличие же во внешних узлах всех ключей и указателей на
соседние листы, предоставляет новый способ обхода дерева --- последовательно по
листам, что дает возможность быстрее обрабатывать запросы на поиск в
диапазоне~\cite{baw}.  Операции вставки и удаления элементов в B$^+$-дерево
аналогичны соответствующим операциям на B-дереве, то есть сложности всех
операций над B$^+$-деревом остаются такими же как в B-дереве. Из-за большей
скорости поиска по сравнению с B-деревьями и аналогичных операций B$^+$-деревья
часто называют просто B-деревьями, подменяя исходный термин.

\subsection{Обученные индексы}

Индексы на основе B-деревьев можно рассматривать как модель сопоставления ключа
с позицией искомой записи в отсортированном массиве, или в терминах машинного
обучения, как дерево принятия решения. Такие индексы сопоставляют ключ положению
записи с минимальной ошибкой, равной нулю, и максимальной ошибкой, равной
размеру страницы, гарантируя, что искомое значение принадлежит указанному
диапазону. Поэтому B-дерево может быть заменено на какую-либо модель машинного
обучения, включая нейронные сети, при условии, что эта модель будет также
гарантировать принадлежность записи некоторому
диапазону~(рисунок~\ref{img:blearnedcomp}), при этом возможно достижение
временной сложности поиска~$O(1)$~\cite{main}.

\imgs{blearnedcomp}{h!}{0.95}{Сравнение индексов на основе B-деревьев и
обученных индексов}

Основываясь на этой идее авторы~\cite{main} пришли к наблюдению, что модель
предсказывающая положение заданного ключа внутри отсортированного массива,
аппроксимирует функцию распределения, что позволяет находить искомое положение с
помощью формулы~\eqref{eq:05}:
\begin{equation}\label{eq:05}
    p = F(K) \cdot N,
\end{equation}

где $p$ --- искомая позиция;

$K$ --- ключ поиска;

$F(K)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска~$K$, то есть $P(X < K)$;

$N$ --- количество ключей.

Описанные выше индексы были названы обученными, однако по ряду
причин~\cite{main} время поиска с помощью описанного выше <<наивного>> подхода
превзошло время поиска с помощью~B-деревьев, поэтому была предложена рекурсивная
модель индекса~(рисунок~\ref{img:rmi}), в которой строится иерархия моделей из
$n$~уровней. Каждая модель на вход получает ключ, на основе которого выбирает
модель на следующем уровне, а модели последнего этапа предсказывают положение
записи. В данную иерархию возможно включение различных моделей: например, на
верхнем уровне использовать нейронные сети, а на нижних простые линейные
регрессионные модели или даже B-деревья. 

\imgs{rmi}{h!}{0.95}{Рекурсивная модель индекса}

С учетом иерархии временная сложность поиска обученных индексов
составляет~$O(\log N)$, однако такая модель по сравнению с B-деревьями каждому
узлу соотносит большее число элементов, что дает меньшее время поиска.
Недостатком такого подхода является невозможность осуществления операций вставки
и удаления без переобучения модели~\cite{ulipp}. Однако дальнейшие
исследования~\cite{alex, apex, ulipp, pgmi} решили эту проблему. Так, был
представлен обновляемый обученный индекс с точными позициями~(\textit{LIPP --- Updatable
Learned Index with Precise Positions}), который для вставки предсказывает
положение ключа и, если оно совпадает с положением другого ключа, создает узел
вмещающий два ключа, а также выполняет перераспределение ключей в поддереве.
LIPP~позволяет с сохранением временной сложности поиска~$O(N)$ достичь
временной сложности вставки --- $O(\log^2 N)$~\cite{ulipp}.

\section{Индексы на основе хеш-таблиц}

Альтернативным способом построения индексов является хеширование. Идея этого
подхода заключается в применении к значению ключа поиска некоторой функции
свертки, называющейся хеш-функцией, по определенному алгоритму вырабатывающей
значение, определяющее адрес в таблице, содержащей ключи и записи или указатели
на записи, называющейся хеш-таблицей~\cite{osip}. Следует учитывать,
что разные ключи могут быть преобразованы хеш-функцией в одно и то же значение.
Такая ситуация называется коллизией и дожна быть каким-либо способом
разрешена.
~\\

К хеш-функциям предъявляется ряд требований~\cite{baw, marvel}:
\begin{itemize}
    \item значения, получаемые в результате применения хеш-функции к ключу
        должны принадлежать диапазону значений, определяющему действительные
        адреса в хеш-таблице;
    \item значения хеш-функции должны быть равномерно распределены для
        уменьшения числа коллизий;
    \item хеш-функция должна при одном и том же входном значении выдавать одно
        и то же выходное.
\end{itemize}

\subsection{Хеш-индексы}

Для построения индекса на основе хеш-таблиц выбирается единица хранения,
именуемая
\mbox{бакетом}~(англ.~\textit{bucket}~---~\mbox{корзина})~\cite{marvel} или
\mbox{хеш-разделом}~\cite{amur}, которая может содержать одну или
несколько индексных записей, при этом их количество фиксировано~\cite{ship}.

Первоначально создается некоторое количество бакетов, которые и составляют
хеш-таблицу. Хеш-функция, получая на вход ключ, отображает его в номер
хеш-раздела в таблице. В случае, если раздел не заполнен, запись, состоящая из
ключа и указателя на данные, помещается в него. Если же в разделе нет места для
вставки новой записи, то есть возникает коллизия и необходимо найти новое место
для вставки~\cite{marvel}. Процесс поиска такого места называется разрешением
коллизии и может выполняться~\cite{baw}:

\begin{itemize}
    \item методом открытой адресации, при котором ищется первая свободная
        позиция в последующих незаполненных хеш-разделах;
    \item методом цепочек переполнения, заключающийся в создании хеш-разделы
        переполнения, к каждому из которых, включая раздел в хеш-таблице,
        добавляется указатель на следующих раздел, что создает связный список,
        относящийся к одному значению хеш-функции;
    \item методом двойного хеширования, при получении коллизии в
        результате применении первой хеш-функции используется вторая и метод
        открытой адресации при повторной коллизии, возможно включение и третьей
        хеш-функции.
\end{itemize}

Операции поиска, вставки и удаления в хеш-индексе зависят от используемого
метода разрешения коллизий. Простейшим в этом плане и рассматривающимся далее
при описании обученных хеш-индексов является метод цепочек переполнения, в
котором поиск, вставка и удаление являются операциями над связным
списком~\cite{baw}.

Пример хеш-индекса с разрешением коллизий по методу цепочек переполнения,
приведен на рисунке~\ref{img:buckethash}.

\imgs{buckethash}{h!}{0.9}{Пример структуры хеш-индекса с разрешением коллизий
методом цепочек переполнения}

Хеш-индексы обеспечивают временную сложность каждой операции в
среднем и лучшем случае --- $O(1)$, в худшем случае --- $O(N)$~\cite{squares}.
При этом хеш-индексы, в отличие индексов, на основе деревьев поиска,
используются только для поиска единичных ключей и не предназначены для поиска
диапазонов.

Существование коллизий подчеркивает потенциальную проблему использования
хеш-индексов~\cite{squares}. Так при заполнении хеш-таблицы более чем на~$70\%$
возникающие коллизии увеличивают время поиска в~1.5-2.5~раза при любом из
методов разрешения коллизий~\cite{baw}.

Для предотвращения появления коллизий используют также методы динамического
хеширования, при котором при вставках и удалениях размер исходной хеш-таблицы
увеличивается или уменьшается соответственно. К таким методам относят:
\begin{itemize}
    \item расширяемое хеширование~(\textit{extendible hashing})~\cite{encycl},
        представляющее значение хеш-функции как битовую строку и использующее из
        нее количество бит, необходимое для однозначной идентификации текущего
        количества записей в таблице;
    \item и линейное хеширование~(\textit{linear hashing})~\cite{encycl}, при
        необходимости изменяющее размер таблицы на один хеш-раздел.
\end{itemize}

Однако они также имеют недостатки. При расширяемом хешировании из-за увеличения
числа учитывающихся разрядов в битовой строке размер таблицы каждый раз
увеличивается в два раза, что может не оправдаться в случае, если дальнейших
вставок в таблицу не произойдет. При этом линейное хеширование не исключает
создание разделов переполнения~\cite{encycl}.

\subsection{Обученные хеш-индексы}

Традиционные хеш-индексы, описанные выше, могут быть рассмотрены как модели
сопоставления ключа позиции искомой записи в неупорядоченном массиве, а
следовательно могут быть заменены моделями машинного обучения.  Обученные
хеш-индексы~\cite{main} основаны на предположении, что модели машинного
обучения, учитывающие распределение ключей, могут без увеличения размеров
хеш-таблицы уменьшить количество коллизий. Для этого функция распределения
ключей~$F$ масштабируется на размер хеш-таблицы~$M$, а в качестве хеш-функции
используется выражение, описывающееся формулой~\eqref{eq:06}:

\begin{equation}\label{eq:06}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

Таким образом, обученный хеш-индекс учитывает эмпирическое распределение ключей,
что позволяет уменьшать количество коллизий по сравнению с обычными
хеш-таблицами~(рисунок~\ref{img:hashlearnedhash}).

\imgw{hashlearnedhash}{h!}{17cm}{Сравнение традиционных и обученных
хеш-индексов}

Так как обученный индекс уменьшает, но не предотвращает появление коллизий, его
временные сложности совпадают со сложностями традиционного хеш-индекса.

\section{Индексы на основе битовых карт}

Индексы на основе битовых карт хранят данные в виде битовых массивов. Обход
индекса осуществляется путем выполнения побитовых логических операций над
битовыми картами~\cite{loshad}. Данные индексы используются, когда атрибут
имеет небольшое количество значений, так как, чем больше записей соответствуют
значению одной и той же битовой карте, тем меньше их требуется, тем меньше
размер индекса~\cite{marvel}. За счет этого свойства данные индексы могут
использоваться для проверки существования записи с заданным ключом в наборе
данных.

\subsection{Фильтр Блума}

Одним из индексов, использующимся для проверки существования записи, является
индекс на основе фильтра Блума.

Фильтр Блума использует массив бит размером~$m$ и $k$~хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$~позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в единицу. Для
проверки принадлежности ключа множеству, ключ также подается на вход
$k$~хеш-функций.  Если какой-либо бит, соответствующий одной из возращенных
позиций, равен нулю, то ключ не входит во множество. Из этого следует, что
данный алгоритм гарантирует отсутствие ложноотрицательных результатов, то есть,
если по результату работы алгоритма ключ не существует в исходном наборе данных,
то он на самом деле отсутствует, если же по результату работы алгоритма ключ
существует, то он может как и принадлежать множеству ключей исходного набора,
так и не принадлежать ему. Временная сложность поиска для индекса на основе
фильтра Блума --- $O(k)$, где $k$ --- количество используемых
хеш-функций~\cite{ship}.

Пример построения индекса на основе фильтра Блума приведен на
рисунке~\ref{img:bloom}, где $h_1, h_2, h_3$ --- хеш-функции.

\imgw{bloom}{h!}{17cm}{Пример построения индекса на основе фильтра Блума}

\subsection{Обученные индексы проверки существования}

Обученные индексы для проверки наличия ключа в наборе данных преследуют цель
уменьшения размера индекса, для этого в результате обучения должна получаться
такая функция, которая относит ключи к одному как можно меньшему набору бит, а
не ключи --- к другому, не пересекающемуся с
первым~(рисунок~\ref{img:learnedBloom}). То
есть, если провести аналогию с индексами на основе хеш-таблиц, где требуется
сокращение числа коллизий, то в данному случае требуется идеальной будет
функция, которая дает коллизии для каждого ключа с каждым, для каждого не ключа
с каждым не ключом, и не дает ни одной коллизии какого-либо ключа с каким-либо
не ключом~\cite{main}.

Основным отличием дающим преимущество обученным индексам в данном случае
является то, что для традиционного фильтра Блума число ложноотрицательных
результатов, равное нулю, и число ложноположительных результатов, равное
константе, выбираются априори, а для обученных индексов проверки существования
для нулевого числа ложноотрицательных результатов, достигается заданное число
ложноположительных результатов на реальных запросах. При этом для поиска
достигается сложность~$O(1)$, так как происходит только вычисление значения
функции~\cite{main}.

\imgw{learnedBloom}{h!}{17cm}{Пример построения обученного индекса проверки
существования}

