\addtocontents{toc}{\protect\vspace{20pt}}
\chapter{\label{impl}Технологическая часть}

\section{Выбор средств программной реализации}

Для реализации метода построения индекса в реляционной базе данных на основе
глубоких нейроных сетей в качестве языка программирования выбран
Python~3.10~\cite{python}. В качестве библиотеки глубокого обучения выбран
Pytorch~2.0.0~\cite{pytorch}.  Для работы с массивами данных выбрана библиотека
numpy~\cite{numpy}.

В качестве реляционной системы управления базами данных выбрана
SQLite~\cite{sqlite}, предоставляющая программный интерфейс виртуальных таблиц,
позволяющих релизовать пользовательский поисковый индекс. Виртуальные таблицы
являются одним из видов расширений SQLite, программный интерфейс которых
предоставляется на языке C~\cite{c}, который и выбран в качестве языка
программирования для взаимодействия с реляционной базой данных.

Для обеспечения взаимодействия между компонентом работы с базой данных и
компонентом, непосредственно реализующий индекс, используются библиотеки языка C
\texttt{Python.h} для работы с объектами языка Python и
\texttt{numpy/arrayobject.h}, предоставляющая программный интерфейс для работы с
numpy-массивами, которые являются основным типом данных, через который
происходит взаимодействие модулей.

\section{Реализация программного обеспечения}

\subsection{Форматы входных и выходных данных}

Основой для построения индекса в качестве входных выступают данные из таблицы
реляционной базы данных SQLite. Требованием к таблице является наличие атрибута
целочисленного типа (\texttt{INTEGER}) с уникальными
значениями~(\texttt{UNIQUE}).

Для создания индекса в аргументах соответствующего запроса должен присутствовать
идентификатор столбца, удовлетворяющего требованию описанному выше, и строковое
имя модели индекса, на основе которой он строится (\texttt{FCNN2} --- для модели
с двумя скрытыми слоями, \texttt{FCNN3} --- с тремя).

В качестве входных данных компонента, реализующего индекса, является набор
значений столбца, идентификатор которого был указан в аргументах запроса на
создание индекса, и идентификаторы строк \texttt{ROWID} индексируемой таблицы.

Выходным данных является указатель на объект, представляющий индекс на основе
глубокой нейронной сети, обученный на предоставленных входных данных.

Формат входных и выходных данных операций с индексом (поиска и вставки) описан в
следующем пункте.

\subsection{Поддерживаемые виды запросов}

Разработанное программное обеспечения предоставляет возможность работы только с
запросами фильтрации, представленными оператором \texttt{WHERE} следующими со
следующими условиями:

\begin{itemize}
    \item \texttt{column operator value},

        где \texttt{column} --- имя проиндексированного столбца,

        \texttt{operator} --- одна из операций сравнения: \texttt{=, <, >, <=, >=},

        \texttt{value} --- некоторое целочисленное значение.

    \item \texttt{column BETWEEN value1 AND value2},
        
        где \texttt{column} --- имя проиндексированного столбца,

        \texttt{value1, value2} --- целочисленные значения, представляющие
        нижнюю и верхнюю границы диапазона.
\end{itemize}

Выходным значением из модуля на языке Python, реализующего индекс, по данным
запросам является numpy-массив с соответствующими запросу значениями ROWID, а
результатом работы программного обеспечения --- набор записей таблицы с ROWID из
представленного массива.

Для вставки поддерживается стандартный запрос \texttt{INSERT}, результатом
которого является индекс с переобученной на новых данных моделью. Запросы
удаления и изменения не поддерживаются, так как являются вторичными для оценки
работы метода.

\subsection{Программный интерфейс виртуальных таблиц}

Виртуальные таблицы SQLite~\cite{vtable} --- это объект базы данных,
представляющий с точки зрения инструкций SQL обычную таблицу или представление,
но обрабатывающий запросы посредством вызова функций программного интерфейса,
которые реализуются пользователем.

Виртальные таблицы являются расширением SQLite, регистрация которых происходит с
использованием макросов и фукнции инициализации, представленных на
линстинге~\ref{lst:init}.

\mylisting[c]{init.c}
{}{Инициализация расширения}{init}{}

При инициализация расширения вирутальной таблицы должен быть зарегистрирован
модуль, описывающийся структурой \texttt{sqlite3\_module}, с помощью функции
регистрации \texttt{sqlite3\_create\_module}, подробное описание которых
представлено на листинге~\ref{lst:module}

\mylisting[c]{module.c}{}{Структура и функция регистрации модуля виртуальной
таблицы}{module}{}

Методы, сигнатуры которых представлены на листинге~\ref{lst:module}, можно
разделить на две группы.

Методы для взаимодействие с таблицей, как с некоторым объектом, к которым
относятся:
\begin{itemize}
    \item \texttt{xCreate} --- создание виртуальной таблицы, при
        выполнении соответствующего запроса, представленного на
        листинге~\ref{lst:create-query};
    \item \texttt{xConnect} --- подключение к виртуальной таблице,
        вызывющийся при выполнении любого запроса к таблице, который
        является первым при повторном подключении к базе данных;
    \item \texttt{xDestroy} --- удаление вирутальной таблицы при
        выполнеивыполнении запроса, представленного на
        листинге~\ref{lst:drop-query};
    \item \texttt{xDisconnect} --- удаление поключения к виртуальной
        таблице.
\end{itemize}

\mylisting[sql]{create.sql}{}{Запрос на создание виртуальной
  таблицы}{create-query}{}
\mylisting[sql]{drop.sql}{}{Запрос на удаление виртуальной
  таблицы}{drop-query}{}

Данные методы работают со структурой \texttt{sqlite3\_vtab}, представленной на
листинге~\ref{lst:vtab}. Для реализации нужных функциональностей указатель на
данную структуру включается в пользовательскую, с которой уже работают
представленные методы посредством преобразования типов. Это дает возможность
передавать между методами вирутальной таблицы нужные данные.

\mylisting[c]{vtab.c}{}{Структура вирутальной таблицы}{vtab}{}

Методы прохода по записям таблицы, использующие для этого структуру курсора
\texttt{sqlite3\_vtab\_cursor}, представленую на листинге~\ref{lst:cursor}, над
которой также реализуют обертку для хранения необходимых для обработки
переменных.

\mylisting[c]{cursor.c}{}{Структура курсора}{cursor}{}

Данная группа представлена методом обработки вставки, удаления и
изменения записи (последний) и методами для прохода по записям таблицы
при поиске:
\begin{itemize}
    \item \texttt{xOpen} --- создание и инициализации структуры курсора;
    \item \texttt{xBestIndex} --- получение параметров фильтрации и
        выбор лучшего индекса для обработки запроса;
    \item \texttt{xFilter} --- получение соответствующих параметрам
        фильтрации записей, установка курсора на первую из них;
    \item \texttt{xEof} --- проверка окончания списка выбранных записей;
    \item \texttt{xNext} --- переход к следующей записи;
    \item \texttt{xColumn} --- обработка столбца записи;
    \item \texttt{xClose} --- удаление структуры курсора;
    \item \texttt{xUpdate} --- реализация запросов вставки, удаления и
        изменения.
\end{itemize}

Для реализации метода построения индекса используются оберточные структуры для
виртуальной таблицы и курсора, представленные на
листинге~\ref{lst:tab-cur-structs}.

\mylisting[c]{tabcurstructs.c}{}{Пользовательские структуры виртуальной таблицы
и курсора}{tab-cur-structs}{}

На листинге~\ref{lst:lindexCreate} представлена реализация метода создания
индекса, реализованного в качестве \texttt{xCreate}. Код инициализации и запуска
обучение индекса в Python через программиный интерфейс приведен на
листинге~\ref{lst:initIndex}.

\textbf{ОСТАВИТЬ ВАЖНОЕ}

\mylisting[c]{lindexCreate.c}{}{Создание индекса}{lindexCreate}{}

\mylisting[c]{initIndex.c}{}{Инициализация индекса}{initIndex}{}

Обработка параметров фильтрации приведена на листинге~\ref{lst:xBestIndex}.
Получение массива подходящих строк и проход для их вывода приведены на
листингах~\ref{lst:xFilter}, \ref{lst:xSearch} соответственно.

\mylisting[c]{xBestIndex.c}{}{Обработка параметров фильтрации
запроса}{xBestIndex}{}

\mylisting[c]{xFilter.c}{}{Выбор строк, удовлетворяющих фильтру}{xFilter}{}

\mylisting[c]{xSearch.c}{}{Реализация работы курсора}{xSearch}{}

\textbf{ВСТАВКА}

\subsection{Реализация индекса}

...

\section{Сборка программного обеспечения}

При сборке расширения SQLite компиляция и линковка происходит с флагами,
обычно используемыми при сборке динамический библиотек: флаг \texttt{-fPIC} при
компиляции в объектные файлы для создание позиционно-независимого кода и флаг
\texttt{-shared} для получения файла динамической библиотеки. Дополнительными
флагами при линковке являются флаги подключения библиотек \texttt{-lsqlite3} и
\texttt{-lpython3.10}. Также при компиляции требуется указание путей к
заголовочным файлам \texttt{Python.h} и \texttt{numpy/arrayobject.h}. Их
автоматическое получения, а также ключевые моменты сборки приведены на
листинге~\ref{lst:makefile}.

\mylisting[make]{makefile}{}{Ключевые моменты сборки программного
обеспечения}{makefile}{}

Для работы компонента индекса, реализованного на Python, требуется установка
зависимостей из уже сформированного файла \texttt{requirements.txt} путем
выполения команды, представленной на листинге~\ref{lst:pybuild}. Также для
штатной работы программного обеспечения требуется прописать путь к модулям,
реализованным на языке Python, что приведено на том же листинге.

\mylisting[bash]{pybuild.sh}{}{Подготовка для работы модулей Python}{pybuild}{}

\section{Взаимодействие с программным обеспечением}



\section{Результаты тестирования}

После разработки программного обеспечение было проведно автоматическое
тестирование модуля индекса на основе глубоких нейронных сетей. Были
использованы следующие классы эквивалентности:

\begin{itemize}
    \item поиск существующего единичного ключа;
    \item поиск наименьшего и наибольшего в наборе ключей;
    \item поиск несуществующего ключа;
    \item поиск ключей по условию \texttt{<} с существующим ключом в качестве
        границы;
    \item поиск ключей по условию \texttt{<} с несуществующим ключом в качестве
        границы;
    \item два предудыщих класса по условиям \texttt{>, $<=$, $>=$};
    \item поиск по диапазону c двумя границами;
    \item поиск по диапазону c двумя границами, в который попадают все ключи;
    \item поиск по диапазону c двумя границами, в который не попадает ни один
        ключ.
\end{itemize}

Результаты тестирования представлены на листинге~\ref{lst:auto-test}

\mylisting[bash]{tests.sh}
{}{Результаты автоматического тестирования}{auto-test}{}

Также было проведено ручное интеграционное тестирование программного
обеспечения, взаимодействие с которым происходит через командную строку sqlite3.
Пример работы и тестирования представлен на листинге~\ref{lst:example}.
%firstline=1,lastline=3

\mylisting[bash]{example.sh}{}{Пример работы программного
обеспечения}{example}{}

