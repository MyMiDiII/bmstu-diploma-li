\chapter{Аналитическая часть\label{analysis}}

\section{Основные определения}

Индекс --- это некоторая структура, обеспечивающая быстрый поиск записей в базе
данных~\cite{amur}. Индекс определяет соответствие значения полей или набора
полей --- ключа поиска --- конкретной записи с местоположением этой
записи~\cite{ship}. Это соответствие организуется с помощью индексных записей.
Каждая из них соответствует записи в индексируемой наборе данных --- наборе, по
которому строится индекс --- и содержит два поля: идентификатор записи или
указатель на нее, а также значение индексированного поля в этой
записи~\cite{syore}.

Индексы могут использоваться для поиска по конкретному значению или диапазону
значений, а также для проверки существования элемента в наборе, однако
обеспечение уменьшения времени доступа к записям в общем случае достигается за
счет~\cite{ship}:
\begin{itemize}
    \item упорядочивания индексных записей по ключу поиска, что уменьшает
        количество записей, которые необходимо просмотреть;
    \item а также меньшего размера индекса по сравнению с индексируемой
        таблицей, сокращающего время чтения одного элемента.
\end{itemize}

В то же время индекс является структурой, которая строится в дополнение к
существующим данным, то есть он занимает дополнительный объем памяти и должен
соответствовать текущим данным.  Последнее значит, что индекс необходимо
изменять при вставке или удалении элементов, на что затрачивается время, поэтому
индекс, ускоряя работу СУБД при доступе к данным, замедляет операции изменения
исходного набора данных, что необходимо учитывать\cite{osip}.

Таким образом, индекс может описываться~\cite{ship}:
\begin{itemize}
    \item типом доступа --- поиск записей по атрибуту с конкретным
        значением, или со значением из указанного диапазона;
    \item временем доступа --- время поиска записи или записей;
    \item временем вставки, включающее время поиска правильного места
        вставки, а также время для обновления индекса;
    \item временем удаления, аналогично вставке, включающее время на поиск
        удаляемого элемента и время для обновления индекса;
    \item дополнительной памятью, занимаемой индексной структурой.
\end{itemize}

\section{Индексы в реляционных базах данных}

Построение индексов для ускорения поиска данных используется в базах данных с
различными моделями представления хранимой информации: в реляционных, документо-
и объектно-ориентированных, в базах данных <<ключ-значение>> и др. По
исследованию 2023 года~\cite{popularity} реляционные базы данных являются
первыми по популярности, охватывая 72.7\% рынка против 10.1\%
документоориентированных и 5.4\% баз данных типа <<ключ-значение>>, занимающих
второе и третьи места соответственно. Таким образом, совершенствование индексов
для реляционных баз данных является актуальной задачей.

Реляционные базы данных~\cite{halimon} основаны на реляционной модели,
представляющей сущности и связи между ними в виде отношений — двумерных таблиц,
каждая строка~(кортеж) которых является записью, содержащей данные о конкретном
объекте данной сущности, а столбцы — ее свойствами, называющиеся атрибутами. То
есть реляционная база данных представляет собой совокупность связанных между
собой отношений, каждое из которых содержит информацию о соответствующей
сущности в структурированном виде.

Особенностями построения индексов в реляционных базах данных является то, что
каждый индекс строится по определенной таблице, при этом каждая индексная запись
содержит  указатель на определенную строку таблицы, а также ключ поиска, в
качестве которого могут быть выбраны:

\begin{itemize}
    \item первичные ключи, однозначно идентифицирующие запись в таблице, для
    ускоmрения доступа к конкретным записям;
    \item внешние ключи, обеспечивающие связи между отношениями, для быстрого
    доступа к связанным записям в разных таблицах;
    \item другие атрибуты, по которым наиболее часто поступают запросы.
\end{itemize}

Остальные вышеописанные свойства индексов верны и в случае их применения к
реляционным базам данных, так при построении нескольких индексов следует помнить
о необходимости их изменения при обновлении соответствующей таблицы, иначе при
неконтролируемом создании многих индексов может произойти потеря скорости работы
с данными, а не ее увеличение.

\section{Типы индексов}

В общем случае, в том числе и в реляционных базах данных, индексы делятся
на~\cite{ship}:
\begin{itemize}
    \item кластеризованные и некластеризованные;
    \item плотные и разреженные;
    \item одноуровневые и многоуровневые;
    \item а также иметь в своей основе различные структуры, что описывается в
        следующем разделе, так как исследуется в данной работе.
\end{itemize}

В кластеризованных индексах логический порядок ключей определяет
физическое расположение записей, а так как строки в таблице могут быть
упорядочены только в одном порядке, то кластеризованный индекс может быть
только один на таблицу. Логический порядок {некластеризованных} индексов
не влияет на физический, и индекс содержит указатели на записи
таблицы~\cite{osip}.

Плотные индексы~(рисунок~\ref{img:dense}) содержат ключ поиска и
указатель на первую запись с заданным ключом поиска. При этом в кластеризованных
индексах другие записи с заданным ключом будут лежать сразу после первой записи,
так как записи в таких файлах отсортированы по тому же ключу. Плотные
некластеризованные индексы должны содержать список указателей на каждую запись с
заданным ключом поиска~\cite{ship}.
 
\imgs{dense}{h!}{1}{Плотный индекс}

В разреженных индексах~(рисунок~\ref{img:sparse}) записи содержат
только некоторые значения ключа поиска, а для доступа к элементу отношения
ищется запись индекса с наибольшим меньшим или равным значением ключа поиска,
происходит переход по указателю на первую запись по найденному ключу и далее по
указателям в файле происходит поиск заданной записи. Таким образом, разреженные
индексы могут быть построены только на отсортированных последовательностях
записей, иначе хранения только некоторых ключей поиска будет недостаточно, так
как будет неизвестно, после записи, с каким ключом будет лежать необходимый
элемент отношения~\cite{ship}.

\imgs{sparse}{h!}{1}{Разреженный индекс}

Поиск с помощью плотных индексов быстрее, так как указатель в записи индекса
сразу приводит к необходимым записям. Однако разреженные индексы требуют меньше
дополнительной памяти и сокращают время поддержания структуры индекса в
актуальном состоянии при вставке или удалении~\cite{ship}.

Одноуровневые индексы ссылаются на данные в таблице, индексы же верхнего уровня
многоуровневой структуры ссылаются на индексы нижестоящего
уровня~\cite{ship}~(рисунок~\ref{img:multilevel}).

\imgs{multilevel}{h!}{1}{Многоуровневый индекс}

\section{Построение индексов на основе базовых структур\label{methods}}

Как было сказано выше индексы обеспечивают быстрый поиск записей, поэтому в их
основе лежат структуры, предназначенные для решения этой задачи. По данным
структурам индексы подразделяются на
\begin{itemize}
    \item индексы на основе деревьев поиска,
    \item индексы на основе хеш-таблиц,
    \item индексы на основе битовых карт.
\end{itemize}

При этом каждой из представленных групп индексов соответствует своя подзадача,
которую решают данные индексы, что подробнее описано далее.

\subsection{Индексы на основе деревьев поиска}

Дерево поиска --- иерархическая структура, используемая для поиска
записей, которая осуществляет работу с отсортированными значениями ключей и в
которой каждый переход на более низкий уровень иерархии уменьшает интервал
поиска. При использовании деревьев поиска для построения индексов необходимо
учитывать, что требуется обеспечить как ускорение поиска данных, так и
уменьшение затрат на обновление индекса при вставках и удалениях. По этим
причинам при решении задачи поиска в базах данных используют сбалансированные
сильноветвящиеся деревья~\cite{arki}.

В данном случае сбалансированными деревьями называют такие деревья, что
длины любых двух путей от корня до листьев одинаковы~\cite{encycl}.
Сильноветвящимися же являются деревья, каждый узел которых ссылается на
большое число потомков~\cite{squares}.  Эти условия обеспечивают минимальную
высоту дерева для быстрого поиска и свободное пространство в узлах для внесения
изменений в базу данных без необходимости изменения индекса при каждой операции.

Наиболее используемыми деревьями поиска, имеющими описанные свойства, являются
B-деревья и их разновидность --- B$^+$-деревья~\cite{arki}.

\subsubsection{B-деревья}

B-дерево --- это сбалансированная, сильноветвящаяся древовидная,
работающая с отсортированными значениями структура данных, операции вставки и
удаления в которой не изменяют ее свойств~\cite{loshad}. Все свойства данной
структуры поддерживаются путем сохранения в узлах положений для включения новых
элементов~\cite{baw}. Это осуществляется за счет свойств узлов, которые
определяются порядком B-дерева~$m$.

B-деревом порядка~$m$~\cite{baw, arki} называется дерево поиска, такое
что:

\begin{itemize}
    \item каждый узел имеет формат, описывающийся формулой~\eqref{eq:01}:
        \begin{equation}\label{eq:01}
            (P_1, (K_1, Pr_1), P_2, (K_2, Pr_2), \dots, (K_{q-1}, Pr_{q-1}),
            P_q),
        \end{equation}

        где $q \leqslant m$,

        $P_i$ --- указатель на $i$-ого потомка в случае внутреннего узла или
        пустой указатель в случае внешнего~(листа),

        $K_i$ --- ключи поиска,

        $Pr_i$ --- указатель на запись, соответствующую ключу поиска $K_i$;

    \item для каждого узла выполняется $K_1 < K_2 < \dots < K_q$;

    \item для каждого ключа поиска $X$ потомка, лежащего по указателю $P_i$
        выполняются условия, описывающиеся формулой~\eqref{eq:02}:

        \begin{equation}\label{eq:02}
            \begin{aligned}
                K_{i-1} < X < K_i, & \text{ если } 1 < i < q,\\
                X < K_i, & \text{ если } i = 1,\\
                K_{i-1} < X, & \text{ если } i = q;
            \end{aligned}
        \end{equation}

    \item каждый узел содержит не более $m - 1$~ключей поиска или, что то же
        самое, имеет не более $m$~потомков;

    \item каждый узел за исключением корня содержит не менее $\lceil m / 2
        \rceil - 1$~ключей поиска, или, что то же самое, имеет не менее~$\lceil
        m / 2 \rceil$ потомков;

    \item корень может содержать минимум один ключ, либо, что то же самое, иметь
        минимум два потомка;

    \item каждый узел за исключением листьев, содержащий $q-1$~ключей, имеет
        $q$~потомков;

    \item все листья находятся на одном и том же уровне.
\end{itemize}

В случае с индексами к каждому ключу поиска во всех узлах добавляется указатель
на запись, соответствующую этому ключу. Другими словами, каждый узел содержит
набор указателей, ссылающихся на дочерние узлы, и набор пар, каждая из которых
состоит из ключа поиска и указателя, ссылающегося на данные. При этом записи с
данными хранятся отдельно и частью B-дерева не являются~\cite{arki}.

Пример B-дерева представлен на рисунке~\ref{img:node}.

\imgs{node}{h!}{1}{Пример B-дерева}

Построение B-дерева~\cite{flatfish} начинается с создания корневого узла. В него
происходит вставка до полного заполнения, то есть до того момента, пока все
$q-1$ позиций не будут заняты. При вставке $q$-ого значения создается новый
корень, в который переносится только медиана значений, старый корень разделяется
на два узла, между которыми равномерно распределяются оставшиеся
значения~(рисунок~\ref{img:rootInsert}). Два созданных узла становятся потомками
нового корня.

\imgw{rootInsert}{h!}{17cm}{Пример вставки в B-дерево при заполненном корне}

Когда некорневой узел заполнен и в него должен быть вставлен новый ключ, этот
узел разделяется на два узла на том же уровне, а средняя запись перемещается в
родительский узел вместе с двумя указателями на новые разделенные узлы. Если
родительский узел заполнен, он также разделяется. Разделение может
распространяться вплоть до корневого узла, при разделении которого создается
новый уровень~(рисунок~\ref{img:leafInsert}). Фактически дерево строится
последовательным выполнением операций вставки.

\imgw{leafInsert}{h!}{17cm}{Пример вставки в B-дерево при последовательном
заполнении узлов разных уровней}

Удаление значений основано на той же идее. Нужное значение удаляется из узла, в
котором оно находится, и если количество значений в узле становится меньше
половины максимально возможного количества значений, то узел объединяется с
соседними узлами, что также может распространяться вплоть до корня~\cite{marvel}. 

Поиск в B-дереве начинается с корня. Если искомое ключевое значение $X$ найдено
в узле, то есть какой либо ключ $K_i$ в нем равен $X$, то доступ к нужной записи
осуществляется по соответствующему указателю $Pr_i$. Если значение не найдено,
происходит переход к поддереву по указателю $P_i$, соответствующему наименьшему
значению $i$, такому, что $X < K_i$. Если $X$ больше $K_i$ для любого значения
$i \in \overline{1, q - 1}$, то переход осуществляется по указателю $P_q$.
Далее действия повторяются для того поддерева, к которому произошел переход, до
тех пор, пока не будет найдено нужное значение или не будет достигнут конец
листового узла, что означает отсутствие искомого ключа~\cite{arki}.

Таким образом, можно выделить следующие основные свойства
\mbox{B-деревьев}~\cite{marvel}:
\begin{itemize}
    \item ключи и указатели на данные хранятся во всех узлах дерева;
    \item как следствие первого свойства, поиск различных ключей может
        выполняться проходом по разному числу узлов, но максимальная длина пути
        равна высоте дереве, что дает временную сложность поиска в среднем
        случае --- $O(\log N)$;
    \item операции вставки и удаления также имеют временную сложность в среднем
        случае --- $O(\log N)$;
    \item в случае поиска по ключам, принадлежащим некоторому диапазону,
        требуется переход от дочерних узлов к родительским и наоборот, что
        является главным недостатком B-дерева.
\end{itemize}

\subsubsection{B$^+$-деревья}

Для устранения недостатков B-деревьев были введены B$^+$-деревья~\cite{marvel},
структура которых аналогична структуре B-дерева за исключением двух
моментов~\cite{arki}.  Во-первых, внутренние узлы не содержат указателей на
записи, в них хранятся только значения ключей, то есть внутренние узлы имеют
формат, описывающийся формулой~\eqref{eq:03}:

\begin{equation}\label{eq:03}
    (P_1, K_1, P_2, K_2, \dots, K_{q-1}, P_q),
\end{equation}

где $q \leqslant m$,

$P_i$ --- указатель на $i$-ого потомка,

$K_i$ --- ключи поиска.

Указатели на данные содержатся только в листьях. При этом каждый ключ,
содержащийся во внутренних узлах, встречается в каком-либо листе, то есть
условие, представленное формулой~\eqref{eq:02}, для B$^+$-деревьев
модернизируется в формулу~\eqref{eq:04}:

\begin{equation}\label{eq:04}
    \begin{aligned}
        K_{i-1} < X \leqslant K_i, & \text{ если } 1 < i < q,\\
        X \leqslant K_i, & \text{ если } i = 1,\\
        K_{i-1} < X, & \text{ если } i = q.
    \end{aligned}
\end{equation}

Все остальные свойства B-дерева порядка $m$ верны и для B$^+$-дерева.

Во-вторых, каждый листовой узел содержит только пары (ключ, указатель на данные)
и не содержит указателей на потомков, так как при любых операциях лист не может
стать внутренним узлом, а также структура внешнего узла отличается от структуры
внутренних. При этом в конец каждого листа добавляется указатель на следующий
лист.

Пример B$^+$-дерева приведен на рисунке~\ref{img:bplustree}.

\imgs{bplustree}{h!}{0.95}{Пример B$^+$-дерева}

В силу того, что листы имеют структуру, они могут иметь порядок отличный от
порядка внутренних узлов, что позволяет уменьшить высоту дерева, а следовательно
и количество блоков памяти, к которым необходимо обратиться, что позволяет
сократить время поиска. Наличие же во внешних узлах всех ключей и указателей на
соседние листы, предоставляет новый способ обхода дерева --- последовательно по
листам, что дает возможность быстрее обрабатывать запросы на поиск в
диапазоне~\cite{baw}.  Операции вставки и удаления элементов в B$^+$-дерево
аналогичны соответствующим операциям на B-дереве, то есть сложности всех
операций над B$^+$-деревом остаются такими же как в B-дереве. Из-за большей
скорости поиска по сравнению с B-деревьями и аналогичных операций B$^+$-деревья
часто называют просто B-деревьями, подменяя исходный термин.


\subsection{Индексы на основе хеш-таблиц}

Альтернативным способом построения индексов является хеширование. Идея этого
подхода заключается в применении к значению ключа поиска некоторой функции
свертки, называющейся хеш-функцией, по определенному алгоритму вырабатывающей
значение, определяющее адрес в таблице, содержащей ключи и записи или указатели
на записи, называющейся хеш-таблицей~\cite{osip}. Следует учитывать,
что разные ключи могут быть преобразованы хеш-функцией в одно и то же значение.
Такая ситуация называется коллизией и дожна быть каким-либо способом
разрешена.

К хеш-функциям предъявляется ряд требований~\cite{baw, marvel}:
\begin{itemize}
    \item значения, получаемые в результате применения хеш-функции к ключу
        должны принадлежать диапазону значений, определяющему действительные
        адреса в хеш-таблице;
    \item значения хеш-функции должны быть равномерно распределены для
        уменьшения числа коллизий;
    \item хеш-функция должна при одном и том же входном значении выдавать одно
        и то же выходное.
\end{itemize}

Для построения индекса на основе хеш-таблиц выбирается единица хранения,
именуемая
\mbox{бакетом}~(англ.~\textit{bucket}~---~\mbox{корзина})~\cite{marvel} или
\mbox{хеш-разделом}~\cite{amur}, которая может содержать одну или несколько
индексных записей, при этом их количество фиксировано~\cite{ship}.

Первоначально создается некоторое количество бакетов, которые и составляют
хеш-таблицу. Хеш-функция, получая на вход ключ, отображает его в номер
хеш-раздела в таблице. В случае, если раздел не заполнен, запись, состоящая из
ключа и указателя на данные, помещается в него. Если же в разделе нет места для
вставки новой записи, то есть возникает коллизия и необходимо найти новое место
для вставки~\cite{marvel}. Процесс поиска такого места называется разрешением
коллизии и может выполняться~\cite{baw}:

\begin{itemize}
    \item методом открытой адресации, при котором ищется первая свободная
        позиция в последующих незаполненных хеш-разделах;
    \item методом цепочек переполнения, заключающийся в создании хеш-разделы
        переполнения, к каждому из которых, включая раздел в хеш-таблице,
        добавляется указатель на следующих раздел, что создает связный список,
        относящийся к одному значению хеш-функции;
    \item методом двойного хеширования, при получении коллизии в результате
        применении первой хеш-функции используется вторая и, возможно, третья, а
        также метод открытой адресации при повторной коллизии.
\end{itemize}

Операции поиска, вставки и удаления в хеш-индексе зависят от используемого
метода разрешения коллизий. Простейшим в этом плане и рассматривающимся далее
при описании обученных хеш-индексов является метод цепочек переполнения, в
котором поиск, вставка и удаление являются операциями над связным
списком~\cite{baw}.

Пример хеш-индекса с разрешением коллизий по методу цепочек переполнения,
приведен на рисунке~\ref{img:buckethash}.

\imgs{buckethash}{h!}{0.9}{Пример структуры хеш-индекса с разрешением коллизий
методом цепочек переполнения}

Хеш-индексы обеспечивают временную сложность каждой операции в
среднем и лучшем случае --- $O(1)$, в худшем случае --- $O(N)$~\cite{squares}.
При этом хеш-индексы, в отличие индексов, на основе деревьев поиска,
используются только для поиска единичных ключей и не предназначены для поиска
диапазонов.

Существование коллизий подчеркивает потенциальную проблему использования
хеш-индексов~\cite{squares}. Так при заполнении хеш-таблицы более чем на~$70\%$
возникающие коллизии увеличивают время поиска в~1.5-2.5~раза при любом из
методов разрешения коллизий~\cite{baw}.

Для предотвращения появления коллизий используют также методы динамического
хеширования, при котором при вставках и удалениях размер исходной хеш-таблицы
увеличивается или уменьшается соответственно. К таким методам относят:
\begin{itemize}
    \item расширяемое хеширование~(\textit{extendible hashing})~\cite{encycl},
        представляющее значение хеш-функции как битовую строку и использующее из
        нее количество бит, необходимое для однозначной идентификации текущего
        количества записей в таблице;
    \item и линейное хеширование~(\textit{linear hashing})~\cite{encycl}, при
        необходимости изменяющее размер таблицы на один хеш-раздел.
\end{itemize}

Однако они также имеют недостатки. При расширяемом хешировании из-за увеличения
числа учитывающихся разрядов в битовой строке размер таблицы каждый раз
увеличивается в два раза, что может не оправдаться в случае, если дальнейших
вставок в таблицу не произойдет. При этом линейное хеширование не исключает
создание разделов переполнения~\cite{encycl}.


\subsection{Индексы на основе битовых карт}

Индексы на основе битовых карт хранят данные в виде битовых массивов. Обход
индекса осуществляется путем выполнения побитовых логических операций над
битовыми картами~\cite{loshad}. Данные индексы используются, когда атрибут
имеет небольшое количество значений, так как, чем больше записей соответствуют
значению одной и той же битовой карте, тем меньше их требуется, тем меньше
размер индекса~\cite{marvel}. За счет этого свойства данные индексы могут
использоваться для проверки существования записи с заданным ключом в наборе
данных.

Одним из индексов, использующимся для проверки существования записи, является
индекс на основе фильтра Блума.

Фильтр Блума использует массив бит размером~$m$ и $k$~хеш-функций, каждая из
которых сопоставляет ключ с одну из $m$~позиций. Для добавления элемента в
множество существующих значений ключ подается на вход каждой хеш-функции,
возвращающих позицию бита, который должен быть установлен в единицу. Для
проверки принадлежности ключа множеству, ключ также подается на вход
$k$~хеш-функций.  Если какой-либо бит, соответствующий одной из возращенных
позиций, равен нулю, то ключ не входит во множество. Из этого следует, что
данный алгоритм гарантирует отсутствие ложноотрицательных результатов, то есть,
если по результату работы алгоритма ключ не существует в исходном наборе данных,
то он на самом деле отсутствует, если же по результату работы алгоритма ключ
существует, то он может как и принадлежать множеству ключей исходного набора,
так и не принадлежать ему. Временная сложность поиска для индекса на основе
фильтра Блума --- $O(k)$, где $k$ --- количество используемых
хеш-функций~\cite{ship}.

Пример построения индекса на основе фильтра Блума приведен на
рисунке~\ref{img:bloom}, где $h_1, h_2, h_3$ --- хеш-функции.

\imgh{bloom}{h!}{3.5cm}{Пример построения индекса на основе фильтра Блума}

\section{Применение методов машинного обучения к построению индексов}

\subsection{Обученные индексы поиска в диапазоне}

Индексы на основе B-деревьев можно рассматривать как модель сопоставления ключа
с позицией искомой записи в отсортированном массиве, или в терминах машинного
обучения, как дерево принятия решения. Такие индексы сопоставляют ключ положению
записи с минимальной ошибкой, равной нулю, и максимальной ошибкой, равной
размеру страницы, гарантируя, что искомое значение принадлежит указанному
диапазону. Поэтому B-дерево может быть заменено на какую-либо модель машинного
обучения, включая нейронные сети, при условии, что эта модель будет также
гарантировать принадлежность записи некоторому
диапазону~(рисунок~\ref{img:blearnedcomp}). Такие индексы, в которых
предсказывается положения ключа или диапазона ключей с помощью модели машинного
обучения, называются обученными~(\textit{learned index}).

\imgs{blearnedcomp}{h!}{0.95}{Сравнение индексов на основе B-деревьев и
обученных индексов}

Возможность применения моделей машинного обучения опеспечивается тем, что они,
предсказывая положение заданного ключа внутри отсортированного массива,
аппроксимируют функцию распределения~\cite{main}, что позволяет находить искомое
положение ключа с помощью формулы~\eqref{eq:05}:
\begin{equation}\label{eq:05}
    p = F(K) \cdot N,
\end{equation}

где $p$ --- искомая позиция;

$K$ --- ключ поиска;

$F(K)$ --- функция распределения, дающая оценку вероятности обнаружения
ключа, меньшего или равного ключу поиска~$K$, то есть $P(X < K)$;

$N$ --- количество ключей.

То есть поиск положения ключа с помощью обученной модели представляет собой
вычисление значения некоторой функции, что на первый взгляд может обеспечить
достижение временной сложности поиска~$O(1)$. Однако следует
учитывать, что предсказание происходит с некоторой ошибкой, из-за чего возникает
необходимость решения, так называемой, задачи <<последней мили>>, заключающейся
в уточнении найденной позиции ключа~\cite{main}.

Для уточнения могут использоваться различные модели, например, линейные
регрессии при линейности отдельных участков распределения, или B-деревья. Также
для различных промежутков ключей могут быть использованы разные модели. В таком
случае стоится используется рекурсивная модель индекса~(рисунок~\ref{img:rmi}),
в которой строится иерархия моделей из $n$~уровней. Каждая модель на вход
получает ключ, на основе которого выбирает модель на следующем уровне, а модели
последнего этапа предсказывают положение записи.

\imgs{rmi}{h!}{0.80}{Рекурсивная модель индекса}

Таким образом, в лучшем случае для произвольного распределения временная
сложность поиска обученных индексов будет составлять~$O(n)$.  Однако по
сравнению с B-деревьями обученные индексы позволяют сократить число узлов в
иерархии, что дает меньшее время поиска, а также уменьшить число дополнительных
указателей для поддержания связей различных частей структуры, что позволяет
сократить занимаемую индексом память. Ее сокращение в том числе происходит и за
счет постоянного не зависящего от числа ключей размера моделей машинного
обучения на верхних уровнях.

Недостатком такого подхода является невозможность осуществления операций вставки
и удаления без переобучения модели~\cite{ulipp}. Однако дальнейшие
исследования~\cite{alex, apex, ulipp, pgmi} решили эту проблему.

\subsection{Обученные хеш-индексы}

Традиционные хеш-индексы, описанные выше, могут быть рассмотрены как модели
сопоставления ключа позиции искомой записи в неупорядоченном массиве, а
следовательно могут быть заменены моделями машинного обучения.  Обученные
хеш-индексы~\cite{main} основаны на предположении, что модели машинного
обучения, учитывающие распределение ключей, могут без увеличения размеров
хеш-таблицы уменьшить количество коллизий. Для этого функция распределения
ключей~$F$ масштабируется на размер хеш-таблицы~$M$, а в качестве хеш-функции
используется выражение, описывающееся формулой~\eqref{eq:06}:

\begin{equation}\label{eq:06}
    h(K) = F(K) \cdot M,
\end{equation}

где $K$ --- ключ.

Таким образом, обученный хеш-индекс учитывает эмпирическое распределение ключей,
что позволяет уменьшать количество коллизий по сравнению с обычными
хеш-таблицами~(рисунок~\ref{img:hashlearnedhash}).

\imgw{hashlearnedhash}{h!}{17cm}{Сравнение традиционных и обученных
хеш-индексов}

Так как обученный индекс уменьшает, но не предотвращает появление коллизий, его
временные сложности совпадают со сложностями традиционного хеш-индекса.

\subsection{Обученные индексы проверки существования}

Обученные индексы для проверки наличия ключа в наборе данных преследуют цель
уменьшения размера индекса, для этого в результате обучения должна получаться
такая функция, которая относит ключи к одному как можно меньшему набору бит, а
не ключи --- к другому, не пересекающемуся с
первым~(рисунок~\ref{img:learnedBloom}). То
есть, если провести аналогию с индексами на основе хеш-таблиц, где требуется
сокращение числа коллизий, то в данному случае требуется идеальной будет
функция, которая дает коллизии для каждого ключа с каждым, для каждого не ключа
с каждым не ключом, и не дает ни одной коллизии какого-либо ключа с каким-либо
не ключом~\cite{main}.

Основным отличием дающим преимущество обученным индексам в данном случае
является то, что для традиционного фильтра Блума число ложноотрицательных
результатов, равное нулю, и число ложноположительных результатов, равное
константе, выбираются априори, а для обученных индексов проверки существования
для нулевого числа ложноотрицательных результатов, достигается заданное число
ложноположительных результатов на реальных запросах. При этом для поиска
достигается сложность~$O(1)$, так как происходит только вычисление значения
функции~\cite{main}.

\imgw{learnedBloom}{h!}{17cm}{Пример построения обученного индекса проверки
существования}

\clearpage
\section{Сравнение описанных методов\label{classification}}

Выше были описаны структуры данных, которым соответствуют методы построения
индексов. Основными характеристиками, определяющими эффективность данных
методов, являются время поиска и вставки, память, занимаемая структурой и
возможность выполнения подзадач. На основе этого были выделены следующие
критерии для оценки  качества описанных методов:

\begin{itemize}
    \item временная сложность поиска;
    \item временная сложность вставки;
    \item память под структуру;
    \item возможность поиска в диапазоне;
    \item возможность поиска единичных ключей;
    \item возможность проверки существования.
\end{itemize}

В таблице~\ref{tab:01} приведены результаты сравнения рассмотренных методов.
Обученные индексы в таблице представлены единым методом в силу того, что в
основе каждого из них лежит та или иная модель машинного обучения.

{
\fontsize{14pt}{14pt}\selectfont
\captionsetup{format=hang,justification=raggedleft,
              singlelinecheck=off,width=17cm}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}[Hc]{|p{3cm}|p{1.5cm}|p{2cm}|p{3cm}|p{2cm}|p{2.5cm}|}
    \caption{Сравнение методов построения индексов\label{tab:01}}\\
    \hline
    \multicolumn{2}{|c|}{\multirow{2}{*}{\textbf{Метод}}} &
    \multicolumn{3}{|c|}{\textbf{Классические индексы}} &
    \multicolumn{1}{c|}{\multirow{2}{*}{\parbox{2.5cm}{
        \centering\textbf{Обученные индексы}}}}\\
    \cline{3-5}
    \multicolumn{2}{|c|}{} & \multicolumn{1}{c|}{\textbf{B-дерево}} &
    \multicolumn{1}{c|}{\textbf{Хеш-таблица}} &
    \multicolumn{1}{c|}{\parbox{2cm}{\centering\textbf{Фильтр Блума}}} & \\
    \hline
    \multirow{2}{*}{\parbox{3cm}{Временная\\сложность}} &
    поиска & O(log N) & O(1) / O(N) & O(k) & O(1) / O(N)\\
    \cline{2-6}
    & вставки & O(log N) & O(1) / O(N) & O(k) & (*)\\
    \hline
    \multicolumn{2}{|l|}{Память} & Высокая & Средняя & Низкая & Средняя\\
    \hline
    \multicolumn{2}{|l|}{Поиск в диапазоне} & + & - & - & + \\
    \hline
    \multicolumn{2}{|l|}{Поиск единичного ключа} & + & + & - & + \\
    \hline
    \multicolumn{2}{|l|}{Проверка существования} & + & + & + & + \\
    \hline
\end{longtable}
}

$(*)$ --- вставка в обученный индекс требует переобучения, сложность которого
зависит от архитектуры используемой модели машинного обучения.

По приведенной таблице можно сделать вывод, что обученные индексы являются
наиболее универсальным средством в плане существующих подзадач, как и B-деревья,
однако по сравнению с ними имеют возможность сокращения времени поиска и
используемой индексом памяти.

\section{Нейронные сети и построение индексов\label{classification}}

\subsection{Понятие нейронных сетей}

Обученные индексы, преимущества которых были описаны в предыдущем пункте, как
уже было сказано, в своей основе содержат методы машинного обучения, одним из
которых являются нейронный сети.

Нейронные сети~\cite{nndef}, или искусственные нейронные сети представляют собой
математическую модель, основанную на сетях нервных клеток живого организма — их
организации и функционировании. Как и биологическая, искусственная нейронная
сеть состоит из связанных между собой узлов, называемых нейронами, в которых
происходит обработка информации с помощью трех
элементов~(рисунок~\ref{img:neuron}):

\begin{itemize}
    \item синапсов или связей, характеризующихся весами, с помощью которых
        происходит изменение входных сигналов;
    \item сумматора, складывающего входные взвешенные входные сигналы, сюда же
        включаются смещения, отражающие увеличение или уменьшение выходного
        сигнала и обычно включающиеся в матрицу весов, путем добавления
        фиктивного входного сигнала всегда равного единице;
    \item функции активации, определяющая значение выходного сигнала по выходу
        сумматора.
\end{itemize}

\imgh{neuron}{h!}{5cm}{Модель нейрона}

Нейроны объединяются в слои, которые делятся на:
\begin{itemize}
    \item входной слой, принимающий входные сигналы;
    \item выходной слой, выдающий прогнозируемые значения;
    \item скрытые слои, располагающиеся между входным и выходным слоем и
        выполняющие обработку.
\end{itemize}

Число скрытых слоев и число нейронов в каждом из них определяют сложность
модели. В простейшем случае скрытые слои могут отсутствовать. Нейронные сети же
с двумя и более скрытыми слоями называют глубокими~\cite{deeplearning}. Пример
нейронной сети, являющейся глубокой, приведен на рисунке~\ref{img:deepnn}.

\imgh{deepnn}{h!}{5cm}{Глубокая нейронная сеть}

Обучение нейронной сети происходит за счет изменения ее параметров на основе
большого количества обучающих данных. В процессе обучения сеть изменяет веса,
минимизируя ошибку, определяющейся функцией потерь, между предсказанными и
реальными значениями. Обычно обучение происходит путем прямого распространения
сигнала через сеть и обратного распространения ошибки, в ходе которого
корректируются веса и смещения слоев.

Определение характеристик нейронной сети: числа слоев, количества нейронов в
каждом из них, активационных функций, функции потерь~и~т.~д. --- является
нетривиальным и зависит от решаемой задачи.

\subsection{Применение нейронных сетей к построению индексов}

Как уже было сказано выше, индекс представляет собой модель, предсказывающая по
переданному ей в качестве входных данных ключу его положение. В случае, если
массив данных, по которому происходит поиск, отсортирован, описанная модель
аппроксимирует функцию распределения ключей $F(K)$. При этом искусственную
нейронную сеть, обучаемую согласно алгоритму обратного распространения, можно
рассматривать как практический механизм реализации нелинейного отображения
«вход-выход» общего вида~\cite{kalistratov}, то есть как аппроксиматор функций.

Таким образом нейронная сеть, аппрокимирующая функцию распределения ключей,
может быть применена в качестве поискового индекса. Архитектура такой сети
должна иметь один нейрон на входном слое, соответствующий ключу, подаваемому в
качестве входных данных, и один нейрон на выходом слое, соответствующий позиции
или значению функции распределения в качестве выходных данных. При этом
конфигурация скрытых слоев может быть различной.

%Выбор архитектур нейронных
%сетей, используемых в данной работе, подробнее в рассматривается в
%разделе~\ref{design}.

Для построения индекса на основе нейронной сети необходимо обучить описанную
модель, для чего требуется исходный набор ключей, по которому вычисляются
значения функции распределения. На основании значений ключей и соответствующих
им значений функций распределения происходит обучение модели, которая
используется как индекс.

\section{Постановка задачи}

На основе рассуждений, представленных в данном разделе, можно сделать вывод, что
для построения индекса на основе нейронной сети требуется:

\begin{itemize}
    \item исходный набор ключей в качестве входных данных;
    \item правила их предварительной обработки;
    \item модель нейронной сети в качестве основы будущего индекса;
    \item алгоритм обучения нейронной сети, результатом работы которого является
        обученная модуль, представляющая собой индекс.
\end{itemize}

Формально данная задача может быть описана с помощью IDEF0-диаграммы нулевого
уровня, представленной на рисунке~\ref{img:idef0-A0-big}.

\imgs{idef0-A0-big}{h!}{1}{Постановка задачи}

\section*{Вывод}

В данном разделе приведен анализ предметной области, описаны особенности
индексов в реляционных базах данных. Также представлено описание построения
индексов на основе базовых структур и применение методов машинного обучения к
построению индексов. Проведено сравнение индексов на основе B-деревьев,
хеш-таблиц и битовых карт с индексами на основе моделей машинного обучения.
Описано применение нейронных сетей к построению индексов. Была описана
формальная постановка задачи в виде IDEF0-диаграммы.

